## config/class5.cfg

# Determine originating internal servers routing blocks

# Test if call comes from C5 servers
route[C5INBOUND] {
    xlog("L_INFO", "$ci|log|--C5INBOUND route--");

    if(ds_is_from_list(GROUP_C5_SERVERS)){
        remove_hf_re("^X-.*");
        setflag(FLAG_FROM_C5);
        xlog("L_INFO", "$ci|log| Call from CLASS 5\n");
        xlog("L_INFO", "$ci|log| Return \n");
        return 1;
    }

    xlog("L_INFO", "$ci|log| Message not coming from C5\n");
    xlog("L_INFO", "$ci|log| Return \n");
    return -1;
}

# Test if call comes from SIPR servers
route[SIPRINBOUND] {
    xlog("L_INFO", "$ci|log|--SIPRINBOUND route--");
        
    if(ds_is_from_list(GROUP_SIPR_SERVERS)){
        remove_hf_re("^X-.*");
        setflag(FLAG_FROM_SIPR);
        xlog("L_INFO", "$ci|log| Call from SIPR\n");
        xlog("L_INFO", "$ci|log| Return \n");
        return 1;
    }
                                                   
    xlog("L_INFO", "$ci|log| Message not coming from SIPR\n");
    xlog("L_INFO", "$ci|log| Return \n");
    return -1; 
}

# Test if call comes from SBC servers
route[SBCINBOUND] {
    xlog("L_INFO", "$ci|log|--SBCINBOUND route--");
        
    if(ds_is_from_list(GROUP_SBC_SERVERS)){
        remove_hf_re("^X-.*");
        setflag(FLAG_FROM_SBC);
        xlog("L_INFO", "$ci|log| Call from SBC\n");
        xlog("L_INFO", "$ci|log| Return \n");
        return 1;
    }
                                                   
    xlog("L_INFO", "$ci|log| Message not coming from SBC\n");
    xlog("L_INFO", "$ci|log| Return \n");
    return -1; 
}

# Dispatch routes

route[DISPATCH] {
    xlog("L_INFO", "$ci|log|--DISPATCH route--\n");

        route(LBRELAY);
        remove_hf_re("^X-");
        xlog("L_INFO", "$ci|log| return \n");
        return;

}

route[LBRELAY] {
    xlog("L_INFO", "$ci|log|--LBRELAY--\n");

    # Choosing the right route and network interface to use

    # ONLY FOR FULL ROLE
    if(isflagset(FLAG_FROM_PROV)){
        # Call coming from PROV to C5
        $avp(s:lbroute) = GROUP_C5_SERVERS;
        #ifdef MY_IP_ADDRESS_EXTERNAL
          force_send_socket("MY_IP_ADDRESS_INTERNAL");
        #endif
        xlog("L_INFO", "$ci|log| Route to C5 pool : internal interface \n");
    }

    # ONLY FOR FULL ROLE
    if(isflagset(FLAG_FROM_C5)){
        # Call coming from C5 to PROV
        #ifdef MY_IP_ADDRESS_EXTERNAL
          force_send_socket("MY_IP_ADDRESS_EXTERNAL");
          route(RELAY);
        #endif
        xlog("L_INFO", "$ci|log| Route to provider pool : external interface \n");
    }

    # Load balancing process
    xlog("L_INFO", "$ci|log| Start load balancing process \n");
    if(!ds_select_dst($avp(s:lbroute), "4")) {
        xlog("L_WARNING", "$ci|log| No server available in pool - end \n");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
        sl_send_reply("500", "Service Unavailable");
        exit;
    }

    xlog("L_INFO", "$ci|log| List of servers available : $avp(AVP_DST)\n");
    xlog("L_INFO", "$ci|log| Server found : relay message to $du\n");

    if($var(newbranch)==1)
    {
        append_branch();
        $var(newbranch) = 0;
    }
    
    xlog("L_INFO", "$ci|log| return \n");
    t_set_fr(0,1000);
    t_on_failure("RTF_DISPATCH");
    route(RELAY);
    exit;
}

# Manage failure routing cases
failure_route[RTF_DISPATCH] {
    xlog("L_INFO", "$ci|log|--RTF DISPATCH--\n");
    if (t_is_canceled()) {
        exit;
    }

    # next DST - only for 500 or local timeout
    if (t_check_status("500") or (t_branch_timeout() and !t_branch_replied())) {
        #we mark the destination Inactive and Probing
        ds_mark_dst("tp");
        #select the new destination
        if(ds_next_dst()) {
            t_set_fr(0,1000);
            xlog("L_INFO", "$ci|log| Send to next available server : relay message to $du\n");
            t_on_failure("RTF_DISPATCH");
            route(RELAY);
            exit;
        }
        else {
            #last available node failed to reply, no other destination available
            xlog("L_WARNING", "$ci|log| No more server available in pool : END\n");
            send_reply("404", "No destination");
            exit;
        }
    }
}

# Dispatcher detects a destination goes down
event_route[dispatcher:dst-down] {
    xlog("L_ERR", "DISPATCHER|log|C5 server down: $rm $ru ($du)\n");
}

# Dispatcher detects a destination comes up
event_route[dispatcher:dst-up] {
    xlog("L_ERR", "DISPATCHER|log|C5 server up: $rm $ru\n");
}

