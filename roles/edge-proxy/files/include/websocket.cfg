## include/websocket.cfg

#!ifdef WITH_WSS


route[WEB_SIP] {
    if(!has_totag()) {
        if ($proto =~ "ws" && !($ru =~ "transport=ws")) { # Coming from WS, NOT to WS
            setbflag(FLB_NATWS); # Need bridging
        } else {
            if (!($proto =~ "ws") && $ru =~ "transport=ws") { # Coming from NOT WS, going to WS
               setbflag(FLB_NATWS); # Need bridging
            }
                                                                        
         }
         return;
                            
    }

}

onreply_route {
	if ((($Rp == 443) && !(proto == WS || proto == WSS))) {
		xlog("L_WARN", "SIP response received on $Rp\n");
		drop;
	}

	if (nat_uac_test(64)) {
		# Do NAT traversal stuff for replies to a WebSocket connection
		# - even if it is not behind a NAT!
		# This won't be needed in the future if Kamailio and the
		# WebSocket client support Outbound and Path.
		add_contact_alias();
	}
}

event_route[xhttp:request] {
	set_reply_close();
	set_reply_no_connect();

	if ($Rp != 80
#!ifdef WITH_TLS
		&& $Rp != 443
#!endif
	) {
		xlog("L_WARN", "HTTP request received on $Rp\n");
		xhttp_reply("403", "Forbidden", "", "");
		exit;
	}

	xlog("L_DBG", "HTTP Request Received\n");

	if ($hdr(Upgrade)=~"websocket" && $hdr(Connection)=~"Upgrade" && $rm=~"GET") {

		# Validate Host - make sure the client is using the correct
		# alias for WebSockets
		#if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
		#	xlog("L_WARN", "Bad host $hdr(Host)\n");
		#	xhttp_reply("403", "Forbidden", "", "");
		#	exit;
		#}

		# Optional... validate Origin - make sure the client is from an
		# authorised website.	For example,
		#
		# if ($hdr(Origin) != "https://example.com"
		#	&& $hdr(Origin) != "https://example.com") {
		#	xlog("L_WARN", "Unauthorised client $hdr(Origin)\n");
		#	xhttp_reply("403", "Forbidden", "", "");
		#	exit;
		# }

		# Optional... perform HTTP authentication

		# ws_handle_handshake() exits (no further configuration file
		# processing of the request) when complete.
		if (ws_handle_handshake()) {
			# Optional... cache some information about the
			# successful connection
			exit;
		}
	}

	xhttp_reply("404", "Not Found", "", "");
}

event_route[websocket:closed] {
	xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}
#!endif


